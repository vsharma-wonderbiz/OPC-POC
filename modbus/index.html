<!-- modbus_ui.html (no flickering, smooth updates) -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Modbus Register Control UI</title>
  <style>
    body { font-family: Inter, system-ui, -apple-system, Roboto, Arial; background:#f6f8fa; padding:18px; color:#0f172a; }
    .card { background:white; border-radius:10px; padding:14px; box-shadow: 0 6px 20px rgba(2,6,23,0.08); margin-bottom:14px; }
    h1 { margin:0 0 12px 0; font-size:20px; }
    table { width:100%; border-collapse: collapse; margin-top:8px; }
    th, td { padding:8px 10px; text-align:left; border-bottom:1px solid #eef2f7; font-size:14px; }
    .btn { padding:6px 10px; border-radius:8px; border:1px solid #e6e9ef; background:#fff; cursor:pointer; }
    .btn-danger { background:#ef4444; color:#fff; border-color:#ef4444; }
    .btn-success { background:#10b981; color:#fff; border-color:#10b981; }
    .muted { color:#64748b; font-size:13px; }
    .small { font-size:13px; color:#475569; }
    .flex { display:flex; gap:8px; align-items:center; }
    .input { padding:6px 8px; border-radius:6px; border:1px solid #e6e9ef; width:80px; }
    .tiny { font-size:12px; padding:4px 6px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Modbus Simulator — Register Control</h1>
    <div class="flex" style="justify-content:space-between">
      <div class="small">Simulator API: <strong id="apiBase">http://127.0.0.1:8000</strong></div>
      <div class="flex">
        <button id="refresh" class="btn">Refresh</button>
        <button id="pause" class="btn">Pause</button>
      </div>
    </div>
  </div>

  <div id="unitsContainer"></div>

  <script>
    const API_BASE = 'http://127.0.0.1:8000';
    document.getElementById('apiBase').textContent = API_BASE;

    const refreshBtn = document.getElementById('refresh');
    const pauseBtn = document.getElementById('pause');
    refreshBtn.onclick = fetchStatus;
    pauseBtn.onclick = togglePause;
    let paused = false;

    let isEditing = false;
    const POLL_MS = 1200;
    let pollHandle = null;
    let isInitialized = false;

    const spikeInputCache = {};

    const signalNames = [
      "Voltage", "Current", "Temperature", "Frequency",
      "Vibration", "FlowRate", "RPM", "Torque"
    ];

    async function fetchStatus() {
      if (isEditing) return;
      try {
        const r = await fetch(`${API_BASE}/api/status`);
        if (!r.ok) throw new Error('status fetch failed ' + r.status);
        const j = await r.json();
        paused = j.paused;
        pauseBtn.textContent = paused ? 'Unpause' : 'Pause';
        
        if (!isInitialized) {
          // First time - create full UI
          renderUnits(j.units || {}, j.stopped_indices || {}, j.spikes || []);
          isInitialized = true;
        } else {
          // Already initialized - just update values
          updateValues(j.units || {}, j.stopped_indices || {}, j.spikes || []);
        }
      } catch (e) {
        console.error(e);
        document.getElementById('unitsContainer').innerHTML = `<div class="card"><div class="muted">Cannot reach simulator API at ${API_BASE}. Make sure it's running.</div></div>`;
        isInitialized = false;
      }
    }

    function updateValues(unitsObj, stopped_indices, spikes) {
      // Only update values, don't recreate DOM
      for (const unitIdStr of Object.keys(unitsObj)) {
        const unitId = parseInt(unitIdStr, 10);
        const regs = unitsObj[unitIdStr] || [];
        const stopped = new Set(stopped_indices[unitId] || []);

        // Update stopped indexes display
        const stoppedEl = document.getElementById(`stopped_${unitId}`);
        if (stoppedEl) {
          stoppedEl.textContent = [...stopped].length ? [...stopped].join(', ') : '(none)';
        }

        // Update spikes display
        const spikesEl = document.getElementById(`spikes_${unitId}`);
        if (spikesEl) {
          const unitSpikes = spikes.filter(s => s.unit === unitId)
            .map(s => `idx=${s.idx} mag=${s.magnitude} rem=${Math.max(0, (s.end_time - Date.now() / 1000)).toFixed(2)}s`)
            .join('; ');
          spikesEl.textContent = unitSpikes || '(none)';
        }

        // Update each register row
        for (let i = 0; i < regs.length; i += 2) {
          const idx = i / 2;
          const high = regs[i] ?? 0;
          const scaled = (high / 100).toFixed(3);
          const isStopped = stopped.has(idx);

          // Update scaled value
          const scaledEl = document.getElementById(`scaled_${unitId}_${idx}`);
          if (scaledEl) scaledEl.textContent = scaled;

          // Update high register value
          const highEl = document.getElementById(`high_${unitId}_${idx}`);
          if (highEl) highEl.textContent = high;

          // Update stopped indicator
          const stoppedIndEl = document.getElementById(`stopped_ind_${unitId}_${idx}`);
          if (stoppedIndEl) stoppedIndEl.textContent = isStopped ? '✅' : '—';

          // Update button
          const btn = document.getElementById(`btn_${unitId}_${idx}`);
          if (btn) {
            if (isStopped) {
              btn.textContent = 'Start';
              btn.className = 'btn btn-success';
            } else {
              btn.textContent = 'Stop';
              btn.className = 'btn btn-danger';
            }
          }
        }
      }
    }

    function renderUnits(unitsObj, stopped_indices, spikes) {
      const container = document.getElementById('unitsContainer');
      container.innerHTML = '';

      for (const unitIdStr of Object.keys(unitsObj)) {
        const unitId = parseInt(unitIdStr, 10);
        const regs = unitsObj[unitIdStr] || [];
        const stopped = new Set(stopped_indices[unitId] || []);
        
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <h2>Slave ${unitId}</h2>
          <div class="small">Stopped indexes: <span id="stopped_${unitId}">${[...stopped].length ? [...stopped].join(', ') : '(none)'}</span></div>
          <table>
            <thead><tr><th>#</th><th>Signal</th><th>Scaled</th><th>HighReg</th><th>Stopped</th><th>Action</th></tr></thead>
            <tbody id="tbody_${unitId}"></tbody>
          </table>
          <div style="margin-top:8px" class="small">Active spikes: <span id="spikes_${unitId}"></span></div>
        `;
        
        const tbody = card.querySelector(`#tbody_${unitId}`);

        for (let i = 0; i < regs.length; i += 2) {
          const idx = i / 2;
          const high = regs[i] ?? 0;
          const scaled = (high / 100).toFixed(3);
          const isStopped = stopped.has(idx);

          const cachedMag = spikeInputCache[`${unitId}_${idx}`]?.mag || '';
          const cachedDur = spikeInputCache[`${unitId}_${idx}`]?.dur || '';

          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${idx}</td>
            <td>${signalNames[idx] ?? ('Signal ' + idx)}</td>
            <td id="scaled_${unitId}_${idx}">${scaled}</td>
            <td id="high_${unitId}_${idx}">${high}</td>
            <td id="stopped_ind_${unitId}_${idx}">${isStopped ? '✅' : '—'}</td>
            <td>
              <button class="btn ${isStopped ? 'btn-success' : 'btn-danger'}" 
                      id="btn_${unitId}_${idx}" 
                      data-unit="${unitId}" 
                      data-idx="${idx}">
                ${isStopped ? 'Start' : 'Stop'}
              </button>
              <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
                <input class="input editable sp_mag" 
                       id="sp_mag_${unitId}_${idx}" 
                       placeholder="mag" 
                       value="${cachedMag}">
                <input class="input editable sp_dur" 
                       id="sp_dur_${unitId}_${idx}" 
                       placeholder="ms" 
                       value="${cachedDur}">
                <button class="btn tiny" 
                        data-unit="${unitId}" 
                        data-idx="${idx}" 
                        data-action="spike">Spike</button>
              </div>
            </td>`;
          tbody.appendChild(tr);
        }

        container.appendChild(card);

        // Update spikes info
        const unitSpikes = spikes.filter(s => s.unit === unitId)
          .map(s => `idx=${s.idx} mag=${s.magnitude} rem=${Math.max(0, (s.end_time - Date.now() / 1000)).toFixed(2)}s`)
          .join('; ');
        document.getElementById(`spikes_${unitId}`).textContent = unitSpikes || '(none)';
      }

      attachEventHandlers();
    }

    function attachEventHandlers() {
      const container = document.getElementById('unitsContainer');

      // Stop/Start buttons
      container.querySelectorAll('button[data-unit]:not([data-action])').forEach(btn => {
        btn.onclick = async () => {
          const unit = btn.getAttribute('data-unit');
          const idx = btn.getAttribute('data-idx');
          try {
            if (btn.textContent.trim() === 'Stop') {
              await fetch(`${API_BASE}/api/units/${unit}/stop/${idx}`, { method: 'POST' });
            } else {
              await fetch(`${API_BASE}/api/units/${unit}/start/${idx}`, { method: 'POST' });
            }
          } catch (e) {
            console.error(e);
          }
          await fetchStatus();
        };
      });

      // Spike buttons
      container.querySelectorAll('button[data-action="spike"]').forEach(btn => {
        btn.onclick = async () => {
          const unit = btn.getAttribute('data-unit');
          const idx = btn.getAttribute('data-idx');
          const key = `${unit}_${idx}`;
          
          const magEl = document.getElementById(`sp_mag_${unit}_${idx}`);
          const durEl = document.getElementById(`sp_dur_${unit}_${idx}`);
          
          let mag = parseInt(magEl?.value || "", 10);
          let dur = parseInt(durEl?.value || "", 10);
          
          if (!Number.isFinite(mag)) mag = 1000;
          if (!Number.isFinite(dur)) dur = 2000;

          try {
            await fetch(`${API_BASE}/api/units/${unit}/spike`, {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify({ idx: parseInt(idx, 10), magnitude: mag, duration_ms: dur })
            });
          } catch (e) {
            console.error(e);
          }

          await fetchStatus();
        };
      });

      // Cache spike inputs
      container.querySelectorAll('.sp_mag, .sp_dur').forEach(inp => {
        inp.addEventListener('input', () => {
          const id = inp.id;
          const parts = id.split('_');
          if (parts.length >= 4) {
            const field = parts[1];
            const unit = parts[2];
            const idx = parts[3];
            const key = `${unit}_${idx}`;
            spikeInputCache[key] = spikeInputCache[key] || {};
            spikeInputCache[key][field] = inp.value;
          }
        });
      });

      // Pause polling while editing
      container.querySelectorAll('input.editable').forEach(inp => {
        inp.onfocus = () => { isEditing = true; };
        inp.onblur = () => { setTimeout(() => { isEditing = false; }, 150); };
      });
    }

    async function togglePause() {
      try {
        await fetch(`${API_BASE}/api/pause`, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ paused: !paused })
        });
      } catch (e) {
        console.error(e);
      }
      await fetchStatus();
    }

    // Initial load + poll
    fetchStatus();
    pollHandle = setInterval(fetchStatus, POLL_MS);
  </script>
</body>
</html>