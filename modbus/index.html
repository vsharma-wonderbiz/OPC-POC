<!-- modbus_ui.html (params-free, working version) -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Modbus Register Control UI</title>
  <style>
    body { font-family: Inter, system-ui, -apple-system, Roboto, Arial; background:#f6f8fa; padding:18px; color:#0f172a; }
    .card { background:white; border-radius:10px; padding:14px; box-shadow: 0 6px 20px rgba(2,6,23,0.08); margin-bottom:14px; }
    h1 { margin:0 0 12px 0; font-size:20px; }
    table { width:100%; border-collapse: collapse; margin-top:8px; }
    th, td { padding:8px 10px; text-align:left; border-bottom:1px solid #eef2f7; font-size:14px; }
    .btn { padding:6px 10px; border-radius:8px; border:1px solid #e6e9ef; background:#fff; cursor:pointer; }
    .btn-danger { background:#ef4444; color:#fff; border-color:#ef4444; }
    .btn-success { background:#10b981; color:#fff; border-color:#10b981; }
    .muted { color:#64748b; font-size:13px; }
    .small { font-size:13px; color:#475569; }
    .flex { display:flex; gap:8px; align-items:center; }
    .input { padding:6px 8px; border-radius:6px; border:1px solid #e6e9ef; width:80px; }
    .tiny { font-size:12px; padding:4px 6px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Modbus Simulator — Register Control</h1>
    <div class="flex" style="justify-content:space-between">
      <div class="small">Simulator API: <strong id="apiBase">http://127.0.0.1:8000</strong></div>
      <div class="flex">
        <button id="refresh" class="btn">Refresh</button>
        <button id="pause" class="btn">Pause</button>
      </div>
    </div>
  </div>

  <div id="unitsContainer"></div>

  <script>
    const API_BASE = 'http://127.0.0.1:8000';
    document.getElementById('apiBase').textContent = API_BASE;

    const refreshBtn = document.getElementById('refresh');
    const pauseBtn = document.getElementById('pause');
    refreshBtn.onclick = fetchStatus;
    pauseBtn.onclick = togglePause;
    let paused = false;

    // editing/polling control
    let isEditing = false;
    const POLL_MS = 1200;
    let pollHandle = null;

    // cache typed spike inputs so re-renders restore them
    const spikeInputCache = {}; // key: `${unit}_${idx}` -> { mag: "123", dur: "2000" }

    async function fetchStatus() {
      if (isEditing) return;
      try {
        const r = await fetch(`${API_BASE}/api/status`);
        if (!r.ok) throw new Error('status fetch failed ' + r.status);
        const j = await r.json();
        paused = j.paused;
        pauseBtn.textContent = paused ? 'Unpause' : 'Pause';
        renderUnits(j.units || {}, j.stopped_indices || {}, j.spikes || []);
      } catch (e) {
        console.error(e);
        document.getElementById('unitsContainer').innerHTML = `<div class="card"><div class="muted">Cannot reach simulator API at ${API_BASE}. Make sure it's running.</div></div>`;
      }
    }

    function restoreSpikeVal(unit, idx, field, fallback = "") {
      const key = `${unit}_${idx}`;
      const cur = spikeInputCache[key];
      if (cur && cur[field] !== undefined) return cur[field];
      return fallback;
    }

    function renderUnits(unitsObj, stopped_indices, spikes) {
      const container = document.getElementById('unitsContainer');
      container.innerHTML = '';
      const signalNames = [
        "Voltage", "Current", "Temperature", "Frequency",
        "Vibration", "FlowRate", "RPM", "Torque"
      ];

      for (const unitIdStr of Object.keys(unitsObj)) {
        const unitId = parseInt(unitIdStr, 10);
        const regs = unitsObj[unitIdStr] || [];
        const stopped = new Set(stopped_indices[unitId] || []);
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `<h2>Slave ${unitId}</h2>
          <div class="small">Stopped indexes: ${[...stopped].length ? [...stopped].join(', ') : '(none)'}</div>
          <table>
            <thead><tr><th>#</th><th>Signal</th><th>Scaled</th><th>HighReg</th><th>Stopped</th><th>Action</th></tr></thead>
            <tbody></tbody>
          </table>
          <div style="margin-top:8px" class="small">Active spikes: ${spikes.filter(s=>s.unit===unitId).map(s=>`idx=${s.idx} mag=${s.magnitude} rem=${Math.max(0,(s.end_time - Date.now()/1000)).toFixed(2)}s`).join('; ') || '(none)'}</div>
        `;
        const tbody = card.querySelector('tbody');

        for (let i = 0; i < regs.length; i += 2) {
          const idx = i / 2;
          const high = regs[i] ?? 0;
          const scaled = (high / 100).toFixed(3);
          const isStopped = stopped.has(idx);

          // restore any cached spike inputs for this cell
          const cachedMag = restoreSpikeVal(unitId, idx, 'mag', '');
          const cachedDur = restoreSpikeVal(unitId, idx, 'dur', '');

          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${idx}</td>
            <td>${signalNames[idx] ?? ('Signal ' + idx)}</td>
            <td>${scaled}</td>
            <td>${high}</td>
            <td>${isStopped ? '✅' : '—'}</td>
            <td>
              <button class="btn ${isStopped ? 'btn-success' : 'btn-danger'}" data-unit="${unitId}" data-idx="${idx}">
                ${isStopped ? 'Start' : 'Stop'}
              </button>
              <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
                <input class="input editable sp_mag" id="sp_mag_${unitId}_${idx}" placeholder="mag" value="${cachedMag}">
                <input class="input editable sp_dur" id="sp_dur_${unitId}_${idx}" placeholder="ms" value="${cachedDur}">
                <button class="btn tiny" data-unit="${unitId}" data-idx="${idx}" data-action="spike">Spike</button>
              </div>
            </td>`;
          tbody.appendChild(tr);
        }

        container.appendChild(card);
      }

      // HANDLERS

      // stop/start buttons (buttons without data-action)
      container.querySelectorAll('button[data-unit]:not([data-action])').forEach(btn=>{
        btn.onclick = async (ev) => {
          const unit = btn.getAttribute('data-unit');
          const idx = btn.getAttribute('data-idx');
          try {
            if (btn.textContent.trim() === 'Stop') {
              await fetch(`${API_BASE}/api/units/${unit}/stop/${idx}`, { method: 'POST' });
            } else {
              await fetch(`${API_BASE}/api/units/${unit}/start/${idx}`, { method: 'POST' });
            }
          } catch (e) {
            console.error(e);
          }
          isEditing = false;
          await fetchStatus();
        };
      });

      // spike action (reads from cached value or DOM, uses safe defaults)
      container.querySelectorAll('button[data-action="spike"]').forEach(btn=>{
        btn.onclick = async () => {
          const unit = btn.getAttribute('data-unit');
          const idx = btn.getAttribute('data-idx');
          const key = `${unit}_${idx}`;
          const magEl = document.getElementById(`sp_mag_${unit}_${idx}`);
          const durEl = document.getElementById(`sp_dur_${unit}_${idx}`);
          let mag = null, dur = null;
          if (spikeInputCache[key] && spikeInputCache[key].mag !== undefined && spikeInputCache[key].mag !== "") {
            mag = parseInt(spikeInputCache[key].mag, 10);
          } else if (magEl) {
            mag = parseInt(magEl.value || "", 10);
          }
          if (spikeInputCache[key] && spikeInputCache[key].dur !== undefined && spikeInputCache[key].dur !== "") {
            dur = parseInt(spikeInputCache[key].dur, 10);
          } else if (durEl) {
            dur = parseInt(durEl.value || "", 10);
          }
          if (!Number.isFinite(mag)) mag = 1000;
          if (!Number.isFinite(dur)) dur = 2000;

          try {
            await fetch(`${API_BASE}/api/units/${unit}/spike`, {
              method: 'POST',
              headers: {'content-type': 'application/json'},
              body: JSON.stringify({ idx: parseInt(idx,10), magnitude: mag, duration_ms: dur })
            });
          } catch (e) {
            console.error(e);
          }

          isEditing = false;
          await fetchStatus();
        };
      });

      // keep local cache of spike inputs so re-renders restore them
      container.querySelectorAll('.sp_mag, .sp_dur').forEach(inp=>{
        inp.addEventListener('input', (ev) => {
          const id = inp.id; // sp_mag_unit_idx
          const parts = id.split('_'); // ["sp","mag","unit","idx"]
          if (parts.length >= 4) {
            const field = parts[1]; // mag or dur
            const unit = parts[2];
            const idx = parts[3];
            const key = `${unit}_${idx}`;
            spikeInputCache[key] = spikeInputCache[key] || {};
            spikeInputCache[key][field] = inp.value;
          }
        });
      });

      // pause polling while user edits inputs
      container.querySelectorAll('input.editable').forEach(inp=>{
        inp.onfocus = () => { isEditing = true; };
        inp.onblur = () => {
          setTimeout(()=>{ isEditing = false; }, 150);
        };
      });
    }

    async function togglePause() {
      try {
        await fetch(`${API_BASE}/api/pause`, {
          method: 'POST',
          headers: {'content-type':'application/json'},
          body: JSON.stringify({ paused: !paused })
        });
      } catch (e) {
        console.error(e);
      }
      await fetchStatus();
    }

    // initial load + poll
    fetchStatus();
    pollHandle = setInterval(fetchStatus, POLL_MS);
  </script>
</body>
</html>
